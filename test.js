// Built with bun 1.3.8 at 2026-02-20T23:55:25+01:00
// Source code coming soon™
(()=>{var wpCache=webpackChunkdiscord_app.push([[Symbol()],{},(r)=>r]).c;webpackChunkdiscord_app.pop();var PROXY_CHECK="is this a proxy that returns values for any key?";function shouldIgnoreValue(value){if(value==null||value===void 0)return!0;if(value===window)return!0;if(value===document||value===document.documentElement)return!0;if(value[Symbol.toStringTag]==="DOMTokenList"||value[Symbol.toStringTag]==="IntlMessagesProxy")return!0;if(value[PROXY_CHECK]!==void 0)return Reflect.deleteProperty(value,PROXY_CHECK),!0;if(value instanceof Object.getPrototypeOf(Int8Array))return!0;return!1}function find(filter,label){for(let key in wpCache){let mod=wpCache[key];if(!mod?.loaded||shouldIgnoreValue(mod.exports))continue;if(filter(mod.exports))return mod.exports;if(typeof mod.exports!=="object")continue;for(let nestedMod in mod.exports){let nested=mod.exports[nestedMod];if(!shouldIgnoreValue(nested)&&filter(nested))return nested}}throw console.error("Filter:",filter,`
Label:`,label),Error("No module found!")}function findByProps(...props){return find((x)=>props.every((p)=>x[p]!==void 0),`findByProps(${props.map((x)=>JSON.stringify(x)).join(", ")})`)}function findStore(name){return find((x)=>x.constructor?.displayName===name,`findStore(${JSON.stringify(name)})`)}var RestAPI=find((x)=>typeof x==="object"&&x.del&&x.put),SnowflakeUtils=findByProps("isProbablyAValidSnowflake"),QuestUtils=findByProps("N1","CV","Ov"),FluxDispatcher=findByProps("dispatch","subscribe"),MessageUtils=findByProps("receiveMessage");var QuestStore=findStore("QuestStore"),RunningGameStore=findStore("RunningGameStore"),MessageStore=findStore("MessageStore"),SelectedChannelStore=findStore("SelectedChannelStore"),UserStore=findStore("UserStore"),ChannelStore=findStore("ChannelStore"),GuildChannelStore=findStore("GuildChannelStore"),ApplicationStreamingStore=findStore("ApplicationStreamingStore");var isApp="DiscordNative"in window,weAreVerySorry="This task isn't completable in the browser version of Discord. Please use the official desktop version to complete this quest.";var questerUser={username:"Quester",discriminator:"4739",id:"1444442163130793997",avatar:"c9036e7a07bcdd576f1fa51aaf30d8b3",bot:!0};var override={flags:64,author:questerUser,embeds:[],attachments:[],components:[],mentions:[],mention_channels:[],mention_roles:[],mention_everyone:!1},channelId,messageId;function initTracker(){let channel=SelectedChannelStore.getCurrentlySelectedChannelId();if(!channel)return;let message=MessageStore.getLastNonCurrentUserMessage(channel);if(!message||message.author.id!==questerUser.id||message.flags!==override.flags)message=void 0;if(!message)message={id:SnowflakeUtils.fromTimestamp(Date.now()),timestamp:new Date().toISOString(),type:0,content:"",channel_id:channel,state:"SENT",...override},MessageUtils.receiveMessage(channel,message);channelId=channel,messageId=message.id}var texts=[];function updateTracker(text){if(!channelId||!messageId)return;texts.push(text);let message=MessageStore.getMessage(channelId,messageId);if(!message)return;FluxDispatcher.dispatch({type:"MESSAGE_UPDATE",message:{...message,type:0,content:texts.join(`
`),...override}})}function fmt(level,message,...args){let styles=[],msg=message.replace(/\*\*(.*?)\*\*/g,(_,value)=>{return styles.push("font-weight: bold",""),`%c${value}%c`}).replace(/`(.*?)`/g,(_,value)=>{return styles.push("font-style: italic; color: #d5f5b3",""),`%c${value}%c`}),scope=typeof this==="object"&&!(this instanceof Window)?this:void 0;if(scope)styles.unshift(`font-weight: bold; color: ${scope.color}`,""),msg=`%c[${scope.text}]%c ${msg}`;return updateTracker([{log:"",warn:"⚠️ ",error:"❌ "}[level],scope?.text?`**${scope.text}** » `:"",message].join("")),console[level].apply(console,[msg,...styles,...args])}var log=fmt.bind(window,"log"),warn=fmt.bind(window,"warn"),error=fmt.bind(window,"error");function scoped(text,color){let scope={text,color};return{log:fmt.bind(scope,"log"),warn:fmt.bind(scope,"warn"),error:fmt.bind(scope,"error")}}var sleep=(ms)=>new Promise((res)=>setTimeout(res,ms));function colorify(text){return`#${text.split("").reduce((hash,txt)=>txt.charCodeAt(0)+((hash<<5)-hash),0).toString(16).padStart(6,"0")}`}var ignored=["PLAY_ON_XBOX","PLAY_ON_PLAYSTATION"];async function complete(quest){let tasks=quest.config.taskConfigV2,applicationId=quest.config.application.id,claimedAt=new Date(quest.userStatus.enrolledAt);log(`Completing the **${quest.config.messages.questName}** quest!`),log(`Must complete **${tasks.joinOperator==="and"?"all":"one"}** of these tasks: ${Object.keys(tasks.tasks).map((x)=>`\`${x}\``).join(", ")}`);let pid=Math.floor(Math.random()*1e4)+1000,completed=!1;for(let{type,target}of Object.values(tasks.tasks)){let progress=quest.userStatus.progress[type]?.value??0,s=scoped(type,colorify(type));try{if(type==="WATCH_VIDEO"||type==="WATCH_VIDEO_ON_MOBILE"){let claimedTime=Math.max(Math.floor((Date.now()-claimedAt.getTime()-500)/1000),0),speed=7;if(claimedTime<target)speed=Math.max(Math.min(7,Math.floor(target/(target-claimedTime))),1);if(s.log(`Watching video at **${speed}x** speed, please wait for **${Math.floor((target-progress)/speed)} seconds**`),speed<7)s.log(`Watch speed throttled by Discord to **${speed}x** from **7x** :(`);let interval=speed<3?2:1,done=!1;while(!0){if(progress=Math.min(progress+speed*interval,target),done=(await RestAPI.post({url:`/quests/${quest.id}/video-progress`,body:{timestamp:progress+Math.random()}})).body.completed_at!==null,s.log(`Video progress **${progress}/${target}**`),progress>=target)break;await sleep(interval*1000)}if(!done)await RestAPI.post({url:`/quests/${quest.id}/video-progress`,body:{timestamp:target}})}else if(type==="PLAY_ON_DESKTOP"){if(!isApp){s.warn(weAreVerySorry);continue}let app=(await RestAPI.get({url:`/applications/public?application_ids=${applicationId}`}).then((x)=>x.body))[0],exe=app?.executables?.find((exe2)=>exe2.os==="win32");if(!app||!exe){s.error("Couldn't find a suitable executable to spoof!");continue}let game={name:app.name,id:applicationId,start:Date.now(),cmdLine:`c:/program files/${app.name.toLowerCase()}/${exe.name}`,exeName:exe.name,exePath:`C:/Program Files/${app.name}/${exe.name}`,processName:app.name,pid,elevated:!1,sandboxed:!1,hidden:!1},$getRunningGames=RunningGameStore.getRunningGames,$getGameForPID=RunningGameStore.getGameForPID;RunningGameStore.getRunningGames=()=>{return $getRunningGames().concat(game)},RunningGameStore.getGameForPID=(gpid)=>{return gpid===pid?game:$getGameForPID(gpid)},FluxDispatcher.dispatch({type:"RUNNING_GAMES_CHANGE",removed:[],added:[game],games:RunningGameStore.getRunningGames()});let{promise,resolve}=Promise.withResolvers();FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS",function listener(event){if(event.questId!==quest.id)return;let newProgress=event.userStatus.progress[type]?.value??0;if(newProgress!==progress)progress=newProgress,s.log(`Game progress **${progress}/${target}**`);if(progress>=target)FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS",listener),RunningGameStore.getRunningGames=$getRunningGames,RunningGameStore.getGameForPID=$getGameForPID,FluxDispatcher.dispatch({type:"RUNNING_GAMES_CHANGE",removed:[game],added:[],games:RunningGameStore.getRunningGames()}),resolve()}),s.log(`Spoofed your app to **${exe.name}**, please wait for **${Math.floor((target-progress)/60)} minute(s)**`),await promise}else if(type==="STREAM_ON_DESKTOP"){if(!ApplicationStreamingStore.getAnyStreamForUser(UserStore.getCurrentUser().id)){s.error("You aren't streaming! Make sure you also have **1 viewer** watching your stream.");continue}let $getStreamerActiveStreamMetadata=ApplicationStreamingStore.getStreamerActiveStreamMetadata;ApplicationStreamingStore.getStreamerActiveStreamMetadata=()=>({id:applicationId,pid,sourceName:null});let{promise,resolve}=Promise.withResolvers();FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS",function listener(event){if(event.questId!==quest.id)return;let newProgress=event.userStatus.progress[type]?.value??0;if(newProgress!==progress)progress=newProgress,s.log(`Stream progress **${progress}/${target}**`);if(progress>=target)FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS",listener),ApplicationStreamingStore.getStreamerActiveStreamMetadata=$getStreamerActiveStreamMetadata,resolve()}),s.log(`Spoofed your stream, please wait for **${Math.floor((target-progress)/60)} minute(s)**`),await promise}else if(type==="PLAY_ACTIVITY"){let channel=ChannelStore.getSortedPrivateChannels()?.[0]??Object.values(GuildChannelStore.getAllGuilds()).find((x)=>x?.VOCAL?.length>0)?.VOCAL?.[0]?.channel;if(!channel){s.error("Couldn't find a suitable channel for playing activities!");continue}let stream_key=`call:${channel}:1`;s.log(`Spoofed your activity to **#${channel.name}**, please wait for **${Math.floor((target-progress)/60)} minute(s)**`);while(!0){if((await RestAPI.post({url:`/quests/${quest.id}/heartbeat`,body:{stream_key,terminal:!1}})).body.progress[type].value>=target){await RestAPI.post({url:`/quests/${quest.id}/heartbeat`,body:{stream_key,terminal:!0}});break}await sleep(20000)}}else{if(!ignored.includes(type))s.warn("This task isn't supported! Please message **@nexpid** to add this task.");continue}}catch(err){s.error("Got an error! Please check the console",err);return}if(s.log("Finished!"),completed=!0,tasks.joinOperator==="or")break}if(!completed)warn("Didn't complete any tasks! Is this quest supported?");else log("Finished running script successfully!")}function mapQuest(quest){return{...quest,isEnrolled:!!quest.userStatus?.enrolledAt,isCompleted:quest.userStatus?.enrolledAt&&quest.userStatus.completedAt}}function getQuests(){return QuestStore.quests.values().filter((x)=>new Date(x.config.expiresAt).getTime()>Date.now()).map(mapQuest).toArray()}async function init(id){initTracker();let quests=getQuests(),quest=quests.find((x)=>x.id===id);if(id){if(!quest?.isEnrolled){try{await RestAPI.post({url:`/quests/${id}/enroll`,body:{location:11,is_targeted:!1,metadata_raw:quest?.metadataRaw||null,metadata_sealed:quest?.metadataSealed||null,traffic_metadata_raw:quest?.trafficMetadataRaw||"EAE="}})}catch{return error("Failed to accept the quest! Either it doesn't exist, or it **isn't available in your region**. Please retry with a VPN.")}if(log("Claimed the quest successfully!"),await QuestUtils.N1(),await sleep(1000),quest=getQuests().find((x)=>x.id===id),!quest?.isEnrolled)return error("Quest is not cached yet! Please go to the **Quests menu** for the quest to appear, then run the script again.")}else if(quest.isCompleted)return error(`The **${quest.config.messages.questName}** quest is already completed!`)}if(quest??=quests.find((x)=>x.isEnrolled&&!x.isCompleted),!quest)return error("No uncompleted quest is available! Make sure to accept a quest first.");if(!quest.config.taskConfigV2)return error("Quest is not supported! (missing taskConfigV2)");await complete(quest)}return init;})();
